
![](./Excalidraw/6.%20Алгоритмы%20поиска%202023-11-23%2016.18.19.excalidraw.svg)
### Бинарный поиск

Идея так же проста проста как и гениальна -- имея отсортированный массив, можно отбросить ту его половину, в которой заведомо не будет искомого значения.

```python
from contextlib import contextmanager
from datetime import datetime

@contextmanager
def timer():
    start = datetime.now()
    yield
    end = datetime.now()
    print(end - start)


def test_search(search_func):
    print(f"Testing {search_func.__name__}:", end=' ')
    lst = list(range(100000000))
    to_find = 50000001
    with timer():
        index = search_func(lst, to_find)
    assert index == to_find
    print('Success!')


def linear_search(seq, val):
    for i, elem in enumerate(seq):
        if elem == val:
            return i
    return None


def recursive_binary_search(seq, val):
    def binary_search(seq, val, left, right):
        if left <= right:
            mid = (left + right) // 2
            if seq[mid] == val:
                return mid
            if seq[mid] < val:
                return binary_search(seq, val, mid + 1, right)
            return binary_search(seq, val, left, mid - 1)
        return None
    return binary_search(seq, val, 0, len(seq) - 1)


def iterative_binary_search(seq, val):
    left = 0
    right = len(seq) - 1
    while left <= right:
        mid = (left + right) // 2
        if seq[mid] == val:
            return mid
        if seq[mid] < val:
            left = mid + 1
        else:
            right = mid - 1
    return None


if __name__ == '__main__':
    test_search(linear_search)
    test_search(recursive_binary_search)
    test_search(iterative_binary_search)
```

---
### Сортировки

#### Сортировка пузырьком

* Идём по массиву от начала до конца
* Если встретили пару элементов не в нужном порядке - меняем местами

```
5 7 2 3 8 6 4 1
5 2 3 7 6 4 1 8
2 3 5 6 4 1 7 8
2 3 5 4 1 6 7 8
2 3 4 1 5 6 7 8
2 3 1 4 5 6 7 8
2 1 3 4 5 6 7 8
1 2 3 4 5 6 7 8
```

Временная сложность $O(n^2)$
Память $O(n)$

### Выбор

* Выбираем max элемент
* Ставим в конец (либо минимальный в начало)
* Повторяем, пока есть элементы в неотсортированной части массива

```
5 7 2 3 8 6 4 1 |
5 7 2 3 6 4 1 | 8
5 2 3 6 4 1 | 7 8
5 2 3 4 1 | 6 7 8
2 3 4 1 | 5 6 7 8
2 3 1 | 4 5 6 7 8
2 1 | 3 4 5 6 7 8
1 | 2 3 4 5 6 7 8
| 1 2 3 4 5 6 7 8
```

Временная сложность $O(n^2)$
Память $O(n)$

### Вставки

* Берём элемент из неотсортиованной части массива
* Вставляем его на своё место в отсортированную часть

```
| 5 7 2 3 8 6 4 1
5 | 7 2 3 8 6 4 1
5 7 | 2 3 8 6 4 1
2 5 7 | 3 8 6 4 1
2 3 5 7 | 8 6 4 1
2 3 5 7 8 | 6 4 1
2 3 5 6 7 8 | 4 1
2 3 4 5 6 7 8 | 1
1 2 3 4 5 6 7 8 |
```

Временная сложность $O(n^2)$
Память $O(n)$

### Быстрая сортировка

* Разбиение
	* Выбираем опорный элемент $p$
	* Слева от $p$ будут такие $x: x \le p$
	* Справа $> p$
* Рекурсивное повторение процесса над частями массива

```
		v
5 7 2 3 8 6 4 1
			  v
5 7 2 3 6 4 1 8
	  v
5 7 2 3 6 4 1 8
-------------
	v
1 2 3 6 4 5 7 8
---   -------
		  v
1 2 3 6 4 5 7 8

1 2 3 4 5 6 7 8
```

Временная сложность $O(n \log n)$
Память $O(n)$

### Сортировка двоичным деревом

* Строим двоичное дерево
* Обходим DFS - Inorder traversal

![](./Excalidraw/6.%20Алгоритмы%20поиска%202023-11-23%2017.25.14.excalidraw.svg)

Временная сложность $O(n \log n)$
Память $O(n)$

### Прямая Radix (LSD)

* Начинаем с младшего разряда
* Сначала ставим 0, потом 1

```
0101 0111 0010 0011 1000 0110 0100 0001
   -    -    -    -    -    -    -    -
0010 1000 0110 0100 0101 0111 0011 0001
  -    -    -    -    -    -    -    -
1000 0100 0101 0001 0010 0110 0111 0011
 -    -    -    -    -    -    -    -
1000 0001 0010 0011 0100 0101 0110 0111
-    -    -    -    -    -    -    -
0001 0010 0011 0100 0101 0110 0111 1000

1    2    3    4    5    6    7    8
```

Временная сложность $O(n \log n)$
Память $O(n)$

### Сортировка подсчётом

* массив `a`, содержащий числа от $0$ до $K$
* заводим масив `c[K] = {0}`
* проходим по массиву `a` и делаем `c[a[i]] += 1`
* проходим по массиву `c` и в результат записываем число `i` повторённое `c[i]` раз

```
a: 3 7 2 3 9 6 4 3

   0 1 2 3 4 5 6 7 8 9
c: 0 0 0 0 0 0 0 0 0 0


   0 1 2 3 4 5 6 7 8 9
c: 0 0 1 3 1 0 1 1 0 1


	2 3 3 3 4 6 7 9
```

Временная сложность $O(n + K)$
Память $O(n + K)$
Эффективен при $n >> K$

---

### Практика

Написать класс, реализующий одну из сортировок, для произвольной коллекции элементов.

Подумайте, что делать в случае разных типов как самих коллекций, так и элементов этих коллекций.