
## Динамическая типизация


* Связывание и "переменные"

```python
a = 1
a = 'spam'
```


![](./Excalidraw/0.%20Введение%202023-11-21%2012.13.13.excalidraw.svg)

* Изменяемые и неизменяемые типы

```python
# Изменяемые и неизменяемые объекты
>>> a = 1
>>> a = 1
>>> id(a)
140409780442408
>>> a = 2
>>> id(a)
140409780442440
>>> a += 1
>>> a
3
>>> id(a)
140409780442472
>>> l = [1]
>>> l
[1]
>>> id(l)
140409758248960
>>> l.append(2)
>>> l
[1, 2]
>>> id(l)
140409758248960
>>> 

```

## Функции

```python
def имя(список_параметров):
	pass
```

`def` - исполняемый код

```python
x = 0  

if x:
	def sum(a, b):
		return a + b
else:
	def sum(a, b):
		return a ** b

print(sum(2, 3))

```

### LEGB

Порядок поиска имён
LEGB - Local, Enclosing, Global, Built-in

```python
x = 1 # global

def f1():
	x = 2 # nonlocal
	def f2():
		# global x
		# nonlocal x
		x = 3 # local
		x += 1
		print(x)
	
	f2()
	print(x)
	
f1()
print(x) # built-in
```

### Способы сопоставления аргументов


```python
# 1) Позиционные
def f(a, b, c):
    pass
f(1, 2, 3)


# 2) Ключевые аргументы
def f(a, b, c):
    pass
f(a=1, b=2, c=3)

# 3) Стандартные
def f(a, b=2, c=3):
    pass

# 4) Сбор переменного числа аргументов
def f(*args): # собираем в кортеж (позиционные)
    pass
def f(**kwargs): # собираем в словарь (ключевые)
    pass
```

#### Декораторы

##### Замыкание
1. Вложенная функция
2. Внешняя функция должна возвращать вложенную
3. Вложенная функция должна ссылаться на нелокальное имя

```python
from datetime import datetime

  
def decorator(func):
	def wrapper(*args, **kwargs):
		start = datetime.now()
		result = func(*args, **kwargs)
		end = datetime.now()
		print(f'executiion took {end - start} seconds')
		return result	
	return wrapper

  
@decorator     # то же, что f = decorator(f)
def f(x):
	return x ** 1234
```

## Модули  и пакеты

* Модуль - любой файл `.py` с валидным кодом на Python
* Пакет - директория с модулями/подпакетами и файлом `__init__.py`

![](./Pasted%20image%2020231121125608.png)

## Протокол итерации

Python понимает под итерируемым объектом объект, у которого есть метод `__iter__`, возвращающий итератор.

Итератор -- итерируемый объект, релизующий протокол итерации:
* получение очередного элемента с помощью метода `__next__`
* индикация исчерпания элементов с помощью поднятия `StopIteration`

```python
a = [1, 2, 3]
a = 'spam'
a = {1, 2, 3}
a = {1: 'one', 2: 'two', 3: 'three'}
a = 1

for i in a:
    print(i)
```

## Генераторы

Генерируют значения по некоторому закону согласно концепции "ленивых" вычислений.

Генератор -- итерируемый объект, возвращаемый генераторной функцией или генераторным выражением.
* Генераторные функции -- используют оператор `yield` для выдачи одного значения за раз с сохранением состояния.
 * Генераторные выражения -- выражения, синтаксически идентичные включениям над кортежами, возвращающие анонимный генератор.
 
```python
# генераторная функция
def f():
    n = 1
    while True:
        yield n
        n += 1

# генераторное выражение
g = (i for i in range(5))
```
