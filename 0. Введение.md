
## Динамическая типизация


* Связывание и "переменные"

```python
a = 1
a = 'spam'
```


![[0. Введение 2023-11-21 12.13.13.excalidraw]]

* Изменяемые и неизменяемые типы

```python
# Изменяемые и неизменяемые объекты
>>> a = 1
>>> a = 1
>>> id(a)
140409780442408
>>> a = 2
>>> id(a)
140409780442440
>>> a += 1
>>> a
3
>>> id(a)
140409780442472
>>> l = [1]
>>> l
[1]
>>> id(l)
140409758248960
>>> l.append(2)
>>> l
[1, 2]
>>> id(l)
140409758248960
>>> 

```

## Функции

```python
def имя(список_параметров):
	pass
```

`def` - исполняемый код

```python
x = 0  

if x:
	def sum(a, b):
		return a + b
else:
	def sum(a, b):
		return a ** b

print(sum(2, 3))

```

### LEGB

Порядок поиска имён
LEGB - Local, Enclosing, Global, Built-in

```python
x = 1

def f1():
	x = 2
	def f2():
		nonlocal x
		x += 1
		print(x)
	
	f2()
	print(x)
	
f1()
print(x)
```

### Способы сопоставления аргументов


```python
# 1) Позиционные
def f(a, b, c):
    pass
f(1, 2, 3)


# 2) Ключевые аргументы
def f(a, b, c):
    pass
f(a=1, b=2, c=3)

# 3) Стандартные
def f(a, b=2, c=3):
    pass

# 4) Сбор переменного числа аргументов
def f(*args): # собираем в кортеж (позиционные)
    pass
def f(**kwargs): # собираем в словарь (ключевые)
    pass
```

#### Декораторы

##### Замыкание
1. Вложенная функция
2. Внешняя функция должна возвращать вложенную
3. Вложенная функция должна ссылаться на нелокальное имя

```python
from datetime import datetime

  
def decorator(func):
	def wrapper(*args, **kwargs):
		start = datetime.now()
		result = func(*args, **kwargs)
		end = datetime.now()
		print(f'executiion took {end - start} seconds')
		return result	
	return wrapper

  
@decorator     # то же, что f = decorator(f)
def f(x):
	return x ** 1234
```

## Модули  и пакеты

* Модуль - любой файл `.py` с валидным кодом на Python
* Пакет - директория с поддулями/подпакетами и файлом `__init__.py`

![[Pasted image 20231121125608.png]]